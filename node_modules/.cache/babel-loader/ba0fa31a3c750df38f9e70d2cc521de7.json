{"ast":null,"code":"import { QuestCreate, QuestMean, QuestSd, QuestQuantile } from \"./Quest.js\";\nexport function testing() {\n  console.log(that.state);\n}\nexport function vis_quest(trialsDesired, tGuess_1, tGuessSd_1, tGuess_2, tGuessSd_2, pThreshold, beta, delta, gamma) {\n  var q1 = QuestCreate(tGuess_1, tGuessSd_1, pThreshold, beta, delta, gamma);\n  q1.normalizePdf = 1;\n  var q2 = QuestCreate(tGuess_2, tGuessSd_2, pThreshold, beta, delta, gamma);\n  q2.normalizePdf = 1; // Quest Trial numbers\n\n  var q1_trialnum = 0;\n  var q2_trialnum = 0;\n  var k = 0; //overall trial numbers\n\n  var frame = 0;\n  var log_contrast_1;\n  var log_contrast_2;\n  console.log(q1);\n\n  while (k < trialsDesired * 2) {\n    var nowTime = new Date().getTime() / 1000;\n    k += 1;\n\n    if (q1_trialnum == q2_trialnum) {\n      // if equal trial numbers, time to go to the next one for staircase 1_\n      q1_trialnum = q1_trialnum + 1;\n      currentQ = 1;\n    }\n\n    if (q1_trialnum != q2_trialnum) {\n      // cannot have multiple if and else blocks in Javascript\n      q2_trialnum = q2_trialnum + 1;\n      currentQ = 2;\n    }\n\n    if (currentQ == 1) {\n      if (k == 1) {\n        log_contrast_1 = tGuess_1 + 0.3; //  Make this procedure go from high to low contrast.\n      } // if(k != 1){\n      //     if !isNaN(trialdata_1{q_1_trialnum-1,2})  // Repeat last level if pt did not have recorded response.\n      //             log_contrast_1=QuestQuantile(q_1) // Recommended by Pelli (1987), and still our favorite\n      // }\n      // if ~isnan(trialdata_1{q_1_trialnum,2})\n      //q_1=QuestUpdate(q_1,log_contrast_1,accuracy_1(q_1_trialnum,1)); % Add the new datum (actual test intensity and observer response) to the database.\n      ///////////////////////////DOES TRIALDATA ISNAN HAVE TO BE INCLUDED? //////////////////////////////////////\n      else {\n          if (k == 2) {\n            log_contrast_2 = tGuess_2 - 0.3; // Make this procedure go from low to high contrast\n          } else {\n            log_contrast_2 = QuestQuantile(q2);\n          }\n        }\n    }\n  }\n\n  var math = require('mathjs'); //Statistics\n\n\n  var t1 = QuestMean(q1); // Recommended by Pelli (1989) and King-Smith et al. (1994) as the best way to ascertain threshold.\n\n  var sd1 = QuestSd(q1);\n  var t2 = QuestMean(q2); // Recommended by Pelli (1989) and King-Smith et al. (1994) as the best way to ascertain threshold.\n\n  var sd2 = QuestSd(q2); // Take the arithmetic mean of these two threshold (75%) estimates.\n\n  var tmean = math.mean([t1, t2]);\n  var sdmean = math.mean([sd1, sd2]);\n  var lambda = 0; // normally in config file//////////////////////\n\n  var gamma = 0.01; // normally in config file//////////////////////\n\n  var intensities = gumbel_intensities(q1, q2, tmean, lambda, gamma);\n  return intensities;\n} //   To be used within context of QUEST-like program.  Defines intensities at\n//   which participants are likely to detect tone in noise at 75%\n//   (threshold), 50%, 25% probabilities.  First row of returned matrix are\n//   these labels.  The second gives the intensities in decibels, the third\n//   in scale units (coefficient used to scale full-scaled tone).  Required\n//   inputs are the QUEST structures produced by the CH QUEST procedure via\n//   ch_auditory_quest. q_1 and q_2 variables are the structures produced by\n//   the QUEST procedure.  t_mean is the arithmetic mean of the two threshold\n//   estimates produced by the two interleaved staircases.\n\nexport function gumbel_intensities(q1, q2, tmean) {\n  var intensities = [25, 50, 75, 90];\n}\nexport function ch_QuestBetaAnalysis(q) {\n  console.log(q);\n\n  var math = require('mathjs');\n\n  var q2 = QuestCreate(q.tGuess, q.tGuessSd, q.pThreshold, math.eval(\"2^(1/4)\"), q.delta, q.gamma, 0.02);\n  q2.dim = 250; //var qq = QuestRecompute( q2 ); \n\n  console.log(q2); // var t2= QuestMean(q2); // estimate threshold for each possible beta\n  // var p2= QuestPdf(q2,t2); // get probability of each of these (threshold,beta) combinations\n  // var sd2= QuestSd(q2); // get sd of threshold for each possible beta\n  // var beta2 = q2.beta;\n  // console.log(t2, p2, sd2, beta2);\n  // var p = Math.max(p2); \n  // var index = indexOfMax(p2);\n  // var t = t2[index];\n  // var sd = QuestSd(q2);\n  // p = math.sum(p2);\n  // var betaMean = p2.map(function(x) {return x * beta2});\n  // betaMean = math.sum(betaMean);\n  // betaMean = betaMean / p;\n  //var temp1 = p2.map(function(x) { return (math.pow( (x * beta2), 2) ) } );\n}","map":{"version":3,"sources":["C:\\Users\\Alika\\Desktop\\VCH_APP\\src\\VisualQuest.js"],"names":["QuestCreate","QuestMean","QuestSd","QuestQuantile","testing","console","log","that","state","vis_quest","trialsDesired","tGuess_1","tGuessSd_1","tGuess_2","tGuessSd_2","pThreshold","beta","delta","gamma","q1","normalizePdf","q2","q1_trialnum","q2_trialnum","k","frame","log_contrast_1","log_contrast_2","nowTime","Date","getTime","currentQ","math","require","t1","sd1","t2","sd2","tmean","mean","sdmean","lambda","intensities","gumbel_intensities","ch_QuestBetaAnalysis","q","tGuess","tGuessSd","eval","dim"],"mappings":"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","sourcesContent":["import { QuestCreate, QuestMean, QuestSd, QuestQuantile } from \"./Quest.js\"\r\n\r\n\r\nexport function testing(){\r\n    console.log(that.state);\r\n}\r\n\r\nexport function vis_quest( trialsDesired, tGuess_1, tGuessSd_1, tGuess_2, tGuessSd_2, pThreshold, beta, delta, gamma ){\r\n\r\n    var q1= QuestCreate(tGuess_1, tGuessSd_1, pThreshold, beta, delta, gamma);\r\n    q1.normalizePdf = 1;\r\n\r\n    var q2 = QuestCreate(tGuess_2, tGuessSd_2, pThreshold, beta, delta, gamma);\r\n    q2.normalizePdf = 1;\r\n\r\n    // Quest Trial numbers\r\n    var q1_trialnum = 0;\r\n    var q2_trialnum = 0;\r\n    var k = 0;                      //overall trial numbers\r\n    var frame = 0; \r\n    var log_contrast_1;\r\n    var log_contrast_2;\r\n\r\n    console.log(q1); \r\n\r\n    while(k < (trialsDesired * 2)){\r\n        var nowTime = new Date().getTime() / 1000;     \r\n\r\n        \r\n        k += 1; \r\n\r\n        if(q1_trialnum == q2_trialnum){  // if equal trial numbers, time to go to the next one for staircase 1_\r\n                q1_trialnum = q1_trialnum + 1;\r\n                currentQ = 1;\r\n        }\r\n        if(q1_trialnum != q2_trialnum){  // cannot have multiple if and else blocks in Javascript\r\n            q2_trialnum = q2_trialnum + 1;\r\n            currentQ = 2;\r\n        }\r\n        if( currentQ == 1 ){\r\n            \r\n            if(k == 1){\r\n                log_contrast_1 = tGuess_1 + 0.3;  //  Make this procedure go from high to low contrast.\r\n            }\r\n            // if(k != 1){\r\n            //     if !isNaN(trialdata_1{q_1_trialnum-1,2})  // Repeat last level if pt did not have recorded response.\r\n            //             log_contrast_1=QuestQuantile(q_1) // Recommended by Pelli (1987), and still our favorite\r\n            // }\r\n            // if ~isnan(trialdata_1{q_1_trialnum,2})\r\n            //q_1=QuestUpdate(q_1,log_contrast_1,accuracy_1(q_1_trialnum,1)); % Add the new datum (actual test intensity and observer response) to the database.\r\n\r\n            ///////////////////////////DOES TRIALDATA ISNAN HAVE TO BE INCLUDED? //////////////////////////////////////\r\n\r\n            else{\r\n                if( k == 2 ){\r\n                    log_contrast_2 = tGuess_2 - 0.3;  // Make this procedure go from low to high contrast\r\n                }\r\n                else{\r\n                    log_contrast_2 = QuestQuantile(q2);\r\n                }\r\n            }\r\n        }\r\n                \r\n    }\r\n\r\n    const math = require('mathjs');\r\n\r\n    //Statistics\r\n    var t1 = QuestMean(q1);\t\t// Recommended by Pelli (1989) and King-Smith et al. (1994) as the best way to ascertain threshold.\r\n    var sd1= QuestSd(q1);\r\n    \r\n    var t2 = QuestMean(q2);\t\t// Recommended by Pelli (1989) and King-Smith et al. (1994) as the best way to ascertain threshold.\r\n    var sd2 = QuestSd(q2);\r\n    \r\n    // Take the arithmetic mean of these two threshold (75%) estimates.\r\n    var tmean = math.mean([t1,t2]);\r\n    var sdmean = math.mean([sd1,sd2]);\r\n\r\n    var lambda = 0; // normally in config file//////////////////////\r\n    var gamma = 0.01; // normally in config file//////////////////////\r\n\r\n    var intensities = gumbel_intensities(q1, q2, tmean, lambda, gamma);\r\n\r\n    return intensities; \r\n}\r\n\r\n//   To be used within context of QUEST-like program.  Defines intensities at\r\n//   which participants are likely to detect tone in noise at 75%\r\n//   (threshold), 50%, 25% probabilities.  First row of returned matrix are\r\n//   these labels.  The second gives the intensities in decibels, the third\r\n//   in scale units (coefficient used to scale full-scaled tone).  Required\r\n//   inputs are the QUEST structures produced by the CH QUEST procedure via\r\n//   ch_auditory_quest. q_1 and q_2 variables are the structures produced by\r\n//   the QUEST procedure.  t_mean is the arithmetic mean of the two threshold\r\n//   estimates produced by the two interleaved staircases.\r\n\r\nexport function gumbel_intensities( q1, q2, tmean ){\r\n    \r\n    var intensities = [25, 50, 75, 90];\r\n\r\n}\r\n\r\nexport function ch_QuestBetaAnalysis( q ){\r\n    \r\n    console.log(q); \r\n\r\n    const math = require('mathjs');\r\n\r\n    var q2 =  QuestCreate( q.tGuess, q.tGuessSd, q.pThreshold, math.eval(\"2^(1/4)\"), q.delta, q.gamma, 0.02);\r\n\r\n    q2.dim = 250; \r\n    //var qq = QuestRecompute( q2 ); \r\n\r\n    console.log(q2); \r\n\r\n    // var t2= QuestMean(q2); // estimate threshold for each possible beta\r\n    // var p2= QuestPdf(q2,t2); // get probability of each of these (threshold,beta) combinations\r\n    // var sd2= QuestSd(q2); // get sd of threshold for each possible beta\r\n    // var beta2 = q2.beta;\r\n\r\n    // console.log(t2, p2, sd2, beta2);\r\n\r\n    // var p = Math.max(p2); \r\n    // var index = indexOfMax(p2);\r\n    // var t = t2[index];\r\n    // var sd = QuestSd(q2);\r\n    // p = math.sum(p2);\r\n    // var betaMean = p2.map(function(x) {return x * beta2});\r\n    // betaMean = math.sum(betaMean);\r\n    // betaMean = betaMean / p;\r\n\r\n    //var temp1 = p2.map(function(x) { return (math.pow( (x * beta2), 2) ) } );\r\n}"]},"metadata":{},"sourceType":"module"}